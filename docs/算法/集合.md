---
outline: deep
---

# 集合
## 集合特性
<pre>
一种无序且唯一的数据结构
ES6中有集合，名为Set

常规操作：
去重
判断某元素是否在集合中，求交集
</pre>


```md
//去重
const arr = [1,1,2,2];
const arr2 =  [...new Set(arr)];


//判断元素是否在集合中
const set = new Set(arr)
const has = set.has(1)  //结果是boolean

//求交集
const  set2 = new Set([2,3]);
const set3 = new Set([...set].filter(item => set2.has(item)))

```

## Set操作
<pre>
new，add, delte,has,size
</pre>

## 迭代Set
<pre>
多种迭代方法，Set与Array互转，求交集和差集
</pre>

### add方法
```
let mySet = new Set()

mySet.add(1)
//基础类型添加相同则只有一个，因为set不允许重复

//但添加对象类型，由于引用类型存储在堆内存中，内存位置不同，所以值相等也能存两份
let o = {a:1,b:2}
mySet.add(o)
mySet.add({a:1,b:2})

```
### has方法
```
myadd.has(1)
myadd.has(o)
//结果都为true
```

### delete方法
```
myadd.delete(5)  //删除后size值-1

```

### set迭代方法
```
//第一种 for of
for(let itme of mySet) console.log(itme)

//第二种 mySet.keys()方法
for(let itme of mySet.keys()) console.log(itme)

//第三种 mySet.values()方法
for(let itme of mySet.values()) console.log(itme)

//第四种 验证mySet.entries()方法
for(let [key,item] of mySet.entries()) console.log(key,item)

可以得到set的迭代其实keys和values结果是一样的

```

## set转化
```
set转换为数组
const myArr = [...mySet]

Array.from
const myArr = Array.from(mySet)

数组转set
const mySet2 = new Set([1,2,3,4])

```

## 求交集

```
const intersection = new Set([...mySet].filter(x =>mySet2.has(x)))
```

## 求差集

```
const intersection = new Set([...mySet].filter(x => !mySet2.has(x)))
```



## 两个数组的交集 LC349
<pre>
给定两个数组，编写一个函数来求出他们的交集
</pre>


```
var intersection = function(num1,num2){
    return [...new Set(num1)].filter(n=> nums2.includes(n))

}

```
### Theme Data
<pre>{{ theme }}</pre>

### Page Data
<pre>{{ page }}</pre>

### Page Frontmatter
<pre>{{ frontmatter }}</pre>

## More

Check out the documentation for the [full list of runtime APIs](https://vitepress.dev/reference/runtime-api#usedata).
