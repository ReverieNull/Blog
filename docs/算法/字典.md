---
outline: deep
---

# 字典
## 字典特性
<pre>
与集合类似，字典也是一种存储唯一值的数据结构，但是是以键值对的形式来存储

ES6中的字典叫做Map
</pre>


```md
const m = new Map()

//增 m.set()
m.set('a','aa');

//删 m.delete()
m.set('b','bb')
m.delete('b')
//清空所有
m.clear()

//改
m.set('a','aaa')   //直接覆盖就行

//查 m.get() get拿到的值



```

## 两个数组的交集 LC349
<pre>
给定两个数组，编写一个函数来求出他们的交集
</pre>


```
var intersection = function(num1,num2){
   const m = new Map()
   nums1.forEach(n=>{
        map.set(n,true)
   })
   const res = []
   num2.forEach(n=>{
        if(map.get(n)){
            res.push(n)
            map.delete(n)
        }
   })
   return res;

}

```
## 有效的括号 LC20
<pre>

</pre>


```
var isValid = function(s){
    if(s.length % 2 ===1 ) return false  //能有效则不会是奇数
    const stack = []  //存储
    const map = new Map()
    map.set('(',')')
    map.set('{','}')
    map.set('[',']')  //存储映射关系
    for(let i =0;i<s.length;i++){  //遍历字符串
        const c = s[i]  //拿到当前字符
        if(map.has(c)){  //映射关系中存在
            stack.push(c) //放入栈，这里都放的是左括号
        }else{
            const t = stack[stack.length-1] //因为右括号闭合一定有最靠栈顶的左括号
            if(map.get(t) === c){ //get拿到栈顶的值，然后和当前右括号做对比
                stack.pop() //相同就从栈里挪出
            }else{
                return fasle //如果不相同就说明没闭合，直接false
            }
        }
    }
    return stack.lenght === 0; //配对完发现栈没空就肯定没完全闭合

}

```
## 两数之和LC1
<pre>
给定一个整数数组nums和目标值target，请你找出该数组中和为目标值的那两个整数并返回他们的数组下标
数组中的同一个元素不能使用两边
</pre>
```
var twoSum = function(nums,target){
    const m = new Map()  //放结果
    for(let i =0;i<nums.length;i++){
        const c = nums[i] //拿到当前的值
        const n = target - n //拿到一对的另一个值
        if(map.has(n)){ //map里有n
           return [map.get(n),i] //返回其值和下标
        }else{ 
            map.set(n,i) //没有就把当前值和下标存进去呗
        }
    }
}
```

## 无重复字符的最长子串 LC3
<pre>
给定一个字符串，找出其中不含有重复字符的最长子串的长度
思路：
用双指针维护滑动窗口用来维护子串
不断维护右指针，遇到重复字符就把左指针挪到重复字符下一位
</pre>
```
var lengthOfLongestSubstring = function(s){
    let l = 0;  //左指针
    let res = 0; //结果
    const map = new Map()
    for(let r=0;r<s.length;r++){ //r是右指针
        if(map.has(s[r]) && map.get(s[r] >= l)){ //如果说map里有这个值了，且值在左指针以内
            l = map.get(s[r])+1  //左指针挪到重复值的下一位
        }
        res = Math.max(res, r - l +1)  //求最大值，从之前存的res和当前长度取
        //就是说r-l就是索引长度了，但由于是从0开始的，所以+1
        map.set(s[r],r)  //然后把当前的值和右指针位置存进去
    }
    return res //最后返回长度
}
```
## 最小覆盖子串LC76

<pre>
给一个字符串S，一个字符串T，在S中找出包含T所有字符的最小子串
S中不存在则返回空字符串 ''
S中存在，确保是唯一的答案
步骤：
双指针维护滑动窗口
移动右指针，找到包含T的子串，移动左指针，尽量减少包含T子串的长度
循环
</pre>

```
var minWindow = function(s,t){
    let l =0  //左指针
    let r =0 //右指针
    const need = new Map() //保存t需要的字符
    for(let c of t){  //便利t的字符串
        need.set(c,need.has(c)? need.get(c)+1 : 1); //保存字符，need中存在则个数+1，否则个数为1
    }
    let needType = need.size; //拿到need里字符总体size
    let res= ''  //存放结果
    while(r<s.length){   //循环遍历s
        const c = s[r]  //拿到当前位字符
        if(need.has(c)){  //need中有当前字符
            need.set(c,need.get(c)-1); //将该字符个数-1
            if(need.get(c) === 0) needType--; //如果该字符个数为0，则需要的字符类型-1
        }
        while(needType === 0){ //当需要字符类型为0时，说明目前范围内已经包含了T的对应字串
            cosnt  newRes = s.substring(l,r+1)  //拿到左右指针区间
            if(!res || newRes.length < res.length) res = newRes; //如果目前结果没值或者新串长度
            //小于旧串长度，就把新串长度保存下来
            const c2= s[l]  //拿到左指针的字符
            if(need.has(c2)){ //如果need里有这个字符
                need.set(c2,need.get(c2) + 1) //就让该字符个数+1
                if(need.get(c2) === 1) needType ++  //由于进入该大循环的前提是needtype为0
                //如果说该字符个数为1，那就让needType+1
            }
            l++ //挪动左指针
        }
        r++; //挪动右指针
    }
}

```

### delete方法
```
myadd.delete(5)  //删除后size值-1

```

### set迭代方法
```
//第一种 for of
for(let itme of mySet) console.log(itme)

//第二种 mySet.keys()方法
for(let itme of mySet.keys()) console.log(itme)

//第三种 mySet.values()方法
for(let itme of mySet.values()) console.log(itme)

//第四种 验证mySet.entries()方法
for(let [key,item] of mySet.entries()) console.log(key,item)

可以得到set的迭代其实keys和values结果是一样的

```

## set转化
```
set转换为数组
const myArr = [...mySet]

Array.from
const myArr = Array.from(mySet)

数组转set
const mySet2 = new Set([1,2,3,4])

```

## 求交集

```
const intersection = new Set([...mySet].filter(x =>mySet2.has(x)))
```

## 求差集

```
const intersection = new Set([...mySet].filter(x => !mySet2.has(x)))
```



## 两个数组的交集 LC349
<pre>
给定两个数组，编写一个函数来求出他们的交集
</pre>


```
var intersection = function(num1,num2){
    return [...new Set(num1)].filter(n=> nums2.includes(n))

}

```
### Theme Data
<pre>{{ theme }}</pre>

### Page Data
<pre>{{ page }}</pre>

### Page Frontmatter
<pre>{{ frontmatter }}</pre>

## More

Check out the documentation for the [full list of runtime APIs](https://vitepress.dev/reference/runtime-api#usedata).
