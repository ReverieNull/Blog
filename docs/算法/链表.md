---
outline: deep
---

# 链表

## 链表是多个元素组成的列表
## 元素存储不连续，用next指针连在一起

## 遍历链表
``` md
 let p = a;
 while(p){
    console.log(p.val)
    p = p.next
 }
```
## 插入
``` md
const e = {val:'e'}
c.next = e;
e.next = d;
```
## 删除
```
c.next = d
```


## 删除链表中的节点LC237

### 要求：请编写函数，使其可以删除某个链表中给定的非末尾节点，将只被给定要求被删除的节点
### 现有链表 -- head = [4,5,1,9]   
```
function ListNode(val) {
    this.val = val
    this.next = null
}

var deleteNode = function(node){
    node.val = node.next.val
    node.next = next.next.next
}
```

## 反转链表LC206
<pre>思路: 双指针迭代，prev记录前节点，curr遍历，反转指针</pre>
<pre>输入：head头节点</pre>
<pre>输出：反转后新头节点</pre>

### 思路及代码
<pre>思路：记录，反转
给前任赋null，现任是头节点
然后还有现任的时候，先把下任存好(const next = curr.next)
让现任的next指针去找前任，即 curr.next = prev
把前任换成现任， prev = curr
把现任换成下一任， curr = next
</pre>
```
var reverseList = function(head){
    let p1 = head
    let p2 = null
    while(p1){
        const tmp = p1.next
        p1.next = p2s
        p2 = p1
        p1 = p2.next
    }
    return p2
}

```

``` JS
function reverseList(head){  //传入头节点
    let prev = null, curr = head; //头节点前节点为null，curr拿到头节点
    while(curr){
        const next = curr.next; //拿到当前节点的下一节点
        curr.next = prev;  //当前节点的next指向prev
        prev = curr; //让prev指向curr当前指向的节点
        curr = next; //再让curr指向next
    }
    return prev;
}

```


## 两数相加
### 两个非空链表表示两个非负整数，各自位数按照逆序存储，并且每个节点只能存储一位数字
### 如果我们将两数相加，返回一个新的链表表示它们的和
### 假设除了数字0之外这两个数都不会以0开头

```
var twoadd = function(l1,l2){
    const l3 = new ListNode(0)
    let p1 = l1;
    let p2 = l2;
    let p3 = l3;
    let carry = 0
    while(p1 || p1){
        const v1 = p1 ? p1.val : 0;
        const v2 = p2 ? p2.val : 0;
        const val = v1 + v2 + carry
        carry = Math.floor(val/10)
        p3.next = new ListNode(val % 10)
        if(p1) p1 = p1.next
        if(p2) p2 = p2.next
        p3 = p3.next
    }
    if(carry){
        p3.next = new ListNode(carry)
    }   
     return l3.next
}
```

## 删除排序链表中的重复元素 LC38
### 给定一个排序链表，删除所有重复元素，确保每个元素只出现一次

```
var deleteDuplicates = function(head) {
    let p = head;
    while(p && p.next){
        if(p.val === p.next.val){
            p.next = p.next.next
        }else {
              p = p.next
        }
    }
    return head;
}
```


## 环形链表 LC 141
### 给定一个链表，判断链表中是否有环，我们用pos表示链表尾连接到链表中的位置，如果pos为1则代表链表中没有环
```
var hasCycle = function(head){
    let p1 = head;
    let p2 = head;
    while(p1 && p2 && p2.next){
        let slow = p1.next;
        let fast = p2.next.next;
        if(p1 === p2) return true
    }
    return false
}
```

## 使用链表指针获取JSON节点值
```
const json = {
    a:{b:{c:1}},
    d:{e:2},
}
const path = ['a','b','c']

let p = json;
path.forEach(k =>{
    p = p[k]
}

)


```

### Theme Data
<pre>{{ theme }}</pre>

### Page Data
<pre>{{ page }}</pre>

### Page Frontmatter
<pre>{{ frontmatter }}</pre>

## More

Check out the documentation for the [full list of runtime APIs](https://vitepress.dev/reference/runtime-api#usedata).
