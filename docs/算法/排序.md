---
outline: deep
---

# 寻找第K大

<pre>思路: 分治思想，及快速选择算法或者使用小栈堆，即维护K个元素，堆顶为第K大</pre>
<pre>输入：数组及数字k</pre>
<pre>输出：第k大的数</pre>
<pre>思路：nums是一个数组，我们可以先找k对应数的索引，即排序过后数的对应索引
随后，我们通过快速选择配合分区来进行筛选
首先确定left和right，partition中进行判断，可以以right为基准
然后让j等于左边界，开始循环，每次增加时判断与right的大小
当j对应的值小于基准值，则让其放到左区中，逻辑是 [num[i++],num[j]] = [num[j],num[i]]
第一轮实际上i=j，i++是控制i自增的，也为后面right基准值的放置留下空位
遍历完后，小于基准值的都会在左边，且左区最后一位因为i++为空，此时将基准值放入即可
而右区均大于基准，所以此时return i 即为基准值的索引
那么我们回到quickSelect里，判断我们找到的基准值和目标索引的大小，然后继续调用partition即可
</pre>


``` JS
function findKthLargest(nums,k){
    const len = nums.length; //数组长度
    const target = len - k; //计算目标索引，启动递归
    function quickSelect(left,right){  //快速选择，无需排序
        if(left === right) return nums[left];  //区间只剩一个元素则拿到目标
        const pivotIdx = partition(left,right);  //分区，得到最终索引
        if (pivotIdx === targetIdx) {
        // 基准值就是目标 → 直接返回
            return nums[pivotIdx];
        } else if (pivotIdx > targetIdx) {
            // 目标在左区间 → 递归左区间
            return quickSelect(left, pivotIdx - 1);
        } else {
            // 目标在右区间 → 递归右区间
            return quickSelect(pivotIdx + 1, right);
        }
    }
    function partition(left,right){
        const pivot = nums[right]; //右边界为基准
        let i = left; //标记
        for(let j = left; j < right; j++){ //处理区间
            if(nums[j] <= pivot) [nums[i++],nums[j]] = [nums[j],nums[i]];
            //比如说当前值小于基准值，那就让当前值和左边界的值换一下，然后换完i++
        }
        [nums[i], nums[right]] = [nums[right],nums[i]]
        //这个时候已经换完了，right没有动，及标准值还在最右侧，这个时候i有空位，换过去
        return i;//就是标准值
    }
    return quickSelect(0,len-1)
}

```

<script setup>
import { useData } from 'vitepress'

const { site, theme, page, frontmatter } = useData()
</script>

## Results

### Theme Data
<pre>{{ theme }}</pre>

### Page Data
<pre>{{ page }}</pre>

### Page Frontmatter
<pre>{{ frontmatter }}</pre>

## More

Check out the documentation for the [full list of runtime APIs](https://vitepress.dev/reference/runtime-api#usedata).
